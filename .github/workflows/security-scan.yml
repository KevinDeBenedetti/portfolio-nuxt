name: Security Scan (OWASP ZAP)

on:
  workflow_call:
    inputs:
      target_url:
        description: 'URL to scan'
        required: true
        type: string
      scan_type:
        description: 'Type of scan: baseline, full, api'
        required: false
        type: string
        default: 'baseline'
    outputs:
      alerts_count:
        description: 'Number of security alerts found'
        value: ${{ jobs.zap-scan.outputs.alerts_count }}
  workflow_dispatch:
    inputs:
      target_url:
        description: 'URL to scan'
        required: true
        type: string
        default: 'https://dev.kevindb.dev'
      scan_type:
        description: 'Type of scan'
        required: false
        type: choice
        options:
          - baseline
          - full
          - api
        default: 'baseline'

permissions:
  contents: read
  issues: write
  pull-requests: write
  actions: read

jobs:
  zap-scan:
    name: OWASP ZAP Security Scan
    runs-on: ubuntu-latest
    outputs:
      alerts_count: ${{ steps.parse-results.outputs.alerts_count }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Create working directory
        run: mkdir -p zap-reports

      - name: Check target availability
        run: |
          echo "ðŸ” Checking target availability: ${{ inputs.target_url }}"

          # Use browser-like headers to avoid bot detection
          HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" --max-time 30 \
            -H "User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36" \
            -H "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8" \
            -H "Accept-Language: en-US,en;q=0.5" \
            -H "Accept-Encoding: gzip, deflate, br" \
            -H "Connection: keep-alive" \
            "${{ inputs.target_url }}" || echo "000")

          echo "HTTP Status: $HTTP_STATUS"

          if [[ "$HTTP_STATUS" == "000" ]]; then
            echo "::error::âŒ Target URL is unreachable (connection failed or timeout)"
            exit 1
          elif [[ "$HTTP_STATUS" == "403" ]]; then
            # 403 often means the site is up but blocking automated requests
            # ZAP may still be able to scan it with different headers
            echo "::warning::âš ï¸ Target returned 403 (Forbidden) - site may have bot protection"
            echo "Proceeding with scan anyway - ZAP uses different request patterns"
          elif [[ "$HTTP_STATUS" -ge 400 && "$HTTP_STATUS" -lt 600 ]]; then
            echo "::error::âŒ Target URL returned error status: $HTTP_STATUS"
            echo "The site may be down or misconfigured."
            exit 1
          elif [[ "$HTTP_STATUS" -ge 200 && "$HTTP_STATUS" -lt 400 ]]; then
            echo "âœ… Target is accessible (HTTP $HTTP_STATUS)"
          else
            echo "::warning::âš ï¸ Unexpected HTTP status: $HTTP_STATUS"
          fi

      - name: Run ZAP Baseline Scan
        if: inputs.scan_type == 'baseline'
        uses: zaproxy/action-baseline@v0.15.0
        with:
          target: ${{ inputs.target_url }}
          rules_file_name: '.zap/rules.tsv'
          cmd_options: '-a -j'
          allow_issue_writing: false

      - name: Run ZAP Full Scan
        if: inputs.scan_type == 'full'
        uses: zaproxy/action-full-scan@v0.12.0
        with:
          target: ${{ inputs.target_url }}
          rules_file_name: '.zap/rules.tsv'
          cmd_options: '-a -j'
          allow_issue_writing: false

      - name: Run ZAP API Scan
        if: inputs.scan_type == 'api'
        uses: zaproxy/action-api-scan@v0.9.0
        with:
          target: ${{ inputs.target_url }}
          format: openapi
          rules_file_name: '.zap/rules.tsv'
          cmd_options: '-a -j'
          allow_issue_writing: false

      - name: Verify report generation
        run: |
          # Check if reports were generated (without exposing content)
          if ls report_* 2>/dev/null | head -1 > /dev/null; then
            echo "âœ… Security reports generated successfully"
          else
            echo "âš ï¸ No report files found"
          fi

      - name: Parse ZAP results
        id: parse-results
        run: |
          # ZAP actions generate report_json.json in the workspace root
          REPORT_FILE=""
          for f in report_json.json zap_report.json ./report_json.json; do
            if [[ -f "$f" ]]; then
              REPORT_FILE="$f"
              break
            fi
          done

          if [[ -n "$REPORT_FILE" && -f "$REPORT_FILE" ]]; then
            # Parse counts without exposing vulnerability details in logs
            ALERTS_COUNT=$(jq '[.site[]?.alerts[]?] | length' "$REPORT_FILE" 2>/dev/null || echo "0")
            HIGH_COUNT=$(jq '[.site[]?.alerts[]? | select(.riskcode == "3")] | length' "$REPORT_FILE" 2>/dev/null || echo "0")
            MEDIUM_COUNT=$(jq '[.site[]?.alerts[]? | select(.riskcode == "2")] | length' "$REPORT_FILE" 2>/dev/null || echo "0")
            LOW_COUNT=$(jq '[.site[]?.alerts[]? | select(.riskcode == "1")] | length' "$REPORT_FILE" 2>/dev/null || echo "0")
            INFO_COUNT=$(jq '[.site[]?.alerts[]? | select(.riskcode == "0")] | length' "$REPORT_FILE" 2>/dev/null || echo "0")
          else
            echo "No JSON report found, setting defaults"
            ALERTS_COUNT=0
            HIGH_COUNT=0
            MEDIUM_COUNT=0
            LOW_COUNT=0
            INFO_COUNT=0
          fi

          # Only show counts, not vulnerability details (security best practice for public repos)
          echo "::notice::Security scan completed - Total: $ALERTS_COUNT alerts"

          echo "alerts_count=$ALERTS_COUNT" >> $GITHUB_OUTPUT
          echo "high_count=$HIGH_COUNT" >> $GITHUB_OUTPUT
          echo "medium_count=$MEDIUM_COUNT" >> $GITHUB_OUTPUT
          echo "low_count=$LOW_COUNT" >> $GITHUB_OUTPUT
          echo "info_count=$INFO_COUNT" >> $GITHUB_OUTPUT

          # Save for summary
          echo "ALERTS_COUNT=$ALERTS_COUNT" >> $GITHUB_ENV
          echo "HIGH_COUNT=$HIGH_COUNT" >> $GITHUB_ENV
          echo "MEDIUM_COUNT=$MEDIUM_COUNT" >> $GITHUB_ENV
          echo "LOW_COUNT=$LOW_COUNT" >> $GITHUB_ENV
          echo "INFO_COUNT=$INFO_COUNT" >> $GITHUB_ENV

      - name: Generate scan summary
        id: summary
        run: |
          SCAN_DATE=$(date -u +"%Y-%m-%d %H:%M:%S UTC")
          TARGET="${{ inputs.target_url }}"
          SCAN_TYPE="${{ inputs.scan_type }}"

          # Create summary markdown
          cat << EOF > scan-summary.md
          ## ðŸ”’ OWASP ZAP Security Scan Report

          | Property | Value |
          |----------|-------|
          | **Target URL** | \`$TARGET\` |
          | **Scan Type** | $SCAN_TYPE |
          | **Scan Date** | $SCAN_DATE |
          | **Workflow Run** | [#${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}) |

          ### ðŸ“Š Results Summary

          | Risk Level | Count | Status |
          |------------|-------|--------|
          | ðŸ”´ **High** | $HIGH_COUNT | $([ "$HIGH_COUNT" -gt 0 ] && echo "âš ï¸ Action Required" || echo "âœ… Clear") |
          | ðŸŸ  **Medium** | $MEDIUM_COUNT | $([ "$MEDIUM_COUNT" -gt 0 ] && echo "âš ï¸ Review Recommended" || echo "âœ… Clear") |
          | ðŸŸ¡ **Low** | $LOW_COUNT | $([ "$LOW_COUNT" -gt 0 ] && echo "ðŸ“ Consider Fixing" || echo "âœ… Clear") |
          | ðŸ”µ **Informational** | $INFO_COUNT | â„¹ï¸ Info Only |
          | **Total Alerts** | **$ALERTS_COUNT** | |

          ### ðŸ“¥ Reports Access

          Detailed reports are available as artifacts in this workflow run (retention: 7 days).

          EOF

          # Add detailed vulnerability information if report exists
          REPORT_FILE=""
          for f in report_json.json zap_report.json; do
            if [[ -f "$f" ]]; then
              REPORT_FILE="$f"
              break
            fi
          done

          if [[ -n "$REPORT_FILE" && -f "$REPORT_FILE" ]]; then
            echo "" >> scan-summary.md
            echo "### ðŸ” Vulnerability Details" >> scan-summary.md
            echo "" >> scan-summary.md

            # Parse and display each alert
            python3 << 'PYTHON_SCRIPT' >> scan-summary.md
          import json
          import html
          import re

          def strip_html(text):
              """Remove HTML tags from text"""
              if not text:
                  return ""
              clean = re.sub(r'<[^>]+>', '', text)
              return html.unescape(clean).strip()

          def truncate(text, max_len=500):
              """Truncate text to max length"""
              text = strip_html(text)
              if len(text) > max_len:
                  return text[:max_len] + "..."
              return text

          risk_icons = {
              "3": "ðŸ”´ High",
              "2": "ðŸŸ  Medium",
              "1": "ðŸŸ¡ Low",
              "0": "ðŸ”µ Info"
          }

          try:
              with open("report_json.json", "r") as f:
                  data = json.load(f)

              alerts = []
              for site in data.get("site", []):
                  for alert in site.get("alerts", []):
                      alerts.append(alert)

              # Sort by risk (high to low)
              alerts.sort(key=lambda x: int(x.get("riskcode", "0")), reverse=True)

              for alert in alerts:
                  risk = alert.get("riskcode", "0")
                  risk_label = risk_icons.get(risk, "âšª Unknown")
                  name = alert.get("name", "Unknown")
                  desc = truncate(alert.get("desc", "No description"), 300)
                  solution = truncate(alert.get("solution", "No solution provided"), 300)
                  instances = alert.get("instances", [])
                  count = len(instances)

                  print(f"<details>")
                  print(f"<summary><strong>{risk_label}</strong>: {name} ({count} instance{'s' if count != 1 else ''})</summary>")
                  print(f"")
                  print(f"**Description:** {desc}")
                  print(f"")
                  print(f"**Solution:** {solution}")
                  print(f"")
                  if instances:
                      print(f"**Affected URLs:**")
                      for inst in instances[:5]:  # Limit to 5 instances
                          uri = inst.get("uri", "N/A")
                          print(f"- `{uri}`")
                      if len(instances) > 5:
                          print(f"- ... and {len(instances) - 5} more")
                  print(f"")
                  print(f"</details>")
                  print(f"")

          except Exception as e:
              print(f"Error parsing report: {e}")
          PYTHON_SCRIPT
          fi

          cat << 'EOF' >> scan-summary.md
          <details>
          <summary>ðŸ“– About OWASP ZAP</summary>

          [OWASP ZAP](https://www.zaproxy.org/) (Zed Attack Proxy) is a free, open-source security tool for finding vulnerabilities in web applications.

          - **Baseline Scan**: Quick passive scan for common vulnerabilities
          - **Full Scan**: Comprehensive active scan (takes longer)
          - **API Scan**: Specialized scan for API endpoints

          </details>
          EOF

          echo "SUMMARY_FILE=scan-summary.md" >> $GITHUB_ENV

      - name: Add summary to workflow
        run: cat scan-summary.md >> $GITHUB_STEP_SUMMARY

      - name: Comment on PR
        if: github.event_name == 'pull_request' || github.event.pull_request != null
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const summary = fs.readFileSync('scan-summary.md', 'utf8');

            // Find the PR number
            let prNumber;
            if (context.payload.pull_request) {
              prNumber = context.payload.pull_request.number;
            } else if (context.payload.workflow_run?.pull_requests?.[0]) {
              prNumber = context.payload.workflow_run.pull_requests[0].number;
            }

            if (prNumber) {
              // Find existing comment
              const { data: comments } = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
              });

              const botComment = comments.find(comment =>
                comment.user.type === 'Bot' &&
                comment.body.includes('OWASP ZAP Security Scan Report')
              );

              if (botComment) {
                await github.rest.issues.updateComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: botComment.id,
                  body: summary
                });
              } else {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  body: summary
                });
              }
            }

      - name: Upload ZAP reports (private artifacts)
        uses: actions/upload-artifact@v4
        with:
          name: zap-security-report-${{ github.run_number }}
          path: |
            report_html.html
            report_json.json
            report_md.md
            zap_report.*
          retention-days: 7 # Shorter retention for security reports
          if-no-files-found: warn

      - name: Check for critical vulnerabilities
        if: env.HIGH_COUNT != '0'
        run: |
          echo "::warning::Found $HIGH_COUNT high-risk vulnerabilities!"
          echo "Review the ZAP report artifacts for details."
          # Uncomment the line below to fail the workflow on high-risk findings
          # exit 1
